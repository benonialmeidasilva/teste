package br.com.viavarejo.gateway.impl;

import br.com.viavarejo.gateway.database.entity.ClienteEntity;
import br.com.viavarejo.gateway.database.repository.ClienteRepository;
import br.com.viavarejo.gateway.feign.CdcCorpClient;
import lombok.RequiredArgsConstructor;
import lombok.extern.java.Log;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Log
@Component
@RequiredArgsConstructor
@EnableScheduling
public class VerificacaoDuplicidadeClienteGatewayImpl {

    private final ClienteRepository clienteRepository;
    private final CdcCorpClient cdcCorpClient;
    private FileWriter fwIndex;
    private PrintWriter pwIndex;
    private String txtDirControleIndex;
    private Path pathIndex;
    private Integer codigoClienteIndex;
    private LocalDateTime dataInicializacao;

    @Scheduled(cron = "0 0 23 * * *")
    public void init() {
        try {
            txtDirControleIndex = "src/main/resources/files/verificacaoDuplicidadeClienteIndex.txt";
            pathIndex = Paths.get(txtDirControleIndex);
            String indexStr = Files.readAllLines(pathIndex).get(0);
            codigoClienteIndex = Integer.valueOf(indexStr);
            dataInicializacao = LocalDateTime.now();
            log.info("Iniciando verificação de duplicidades a partir do códigoCliente");
            System.out.println("Iniciando verificação de duplicidades a partir do códigoCliente " + codigoClienteIndex + ".");
            processarVerificacaoDuplicidadeCliente();
            log.info("Fim do processo de verificacao e replicacao de cliente com duplicidade");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void atualizarIndex(Integer codigoClienteIndex) {
        try {
            fwIndex = new FileWriter(txtDirControleIndex, false);
            pwIndex = new PrintWriter(fwIndex);
            pwIndex.write(String.valueOf(codigoClienteIndex));
            pwIndex.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void processarVerificacaoDuplicidadeCliente() {
        log.info("realizando uma lista de clientes paginada de 5000 cada");
        Pageable pageable = PageRequest.of(0, 5000);
        Page<ClienteEntity> listaPageClientes = clienteRepository.findByCodigoClienteGreaterThanOrderByCodigoCliente(codigoClienteIndex, pageable);

        log.info("consultando clientes duplicados ");
        consultarClientes(listaPageClientes.get());

        if(!Thread.currentThread().isInterrupted())
            atualizarIndex(((ClienteEntity) listaPageClientes.get().toArray()[Long.valueOf(listaPageClientes.get().count()).intValue() - 1]).getCodigoCliente());

        log.info("Iniciando o loop com a lista de clientes");
        while (!listaPageClientes.isLast()) {
            if (LocalDateTime.now().isAfter(dataInicializacao.plusHours(6l))) {
                Thread.currentThread().interrupt();
                break;
            }
            log.info("Buscando nova lista de clientes a verificar se ainda existe duplicidade");
            listaPageClientes = clienteRepository.findByCodigoClienteGreaterThanOrderByCodigoCliente(codigoClienteIndex, listaPageClientes.nextPageable());
            log.info("Consultando de replicando as duplicidades");
            consultarClientes(listaPageClientes.get());
            log.info("Atualizando o index de codigo cliente novamente");
            if(!Thread.currentThread().isInterrupted())
                atualizarIndex(((ClienteEntity) listaPageClientes.get().toArray()[Long.valueOf(listaPageClientes.get().count()).intValue() - 1]).getCodigoCliente());
        }
    }

    private void consultarClientes(Stream<ClienteEntity> clienteEntityStream) {
        for (ClienteEntity cliente : clienteEntityStream.collect(Collectors.toList())) {
            try {
                 Thread.sleep(10);
                cdcCorpClient.consultarCliente(String.valueOf(cliente.getCodigoCliente()));
                log.info("consultando cliente  " + cliente.getCodigoCliente());
                codigoClienteIndex = cliente.getCodigoCliente();
                if (LocalDateTime.now().isAfter(dataInicializacao.plusHours(6l))) {
                    atualizarIndex(cliente.getCodigoCliente());
                    log.info("interrompendo a Thread dvido ao tempo estabelecido");
                    Thread.currentThread().interrupt();
                    break;
                }
            } catch (InterruptedException e) {
             log.info("Lote interrompido para o cliente: " + cliente.getCodigoCliente());
            }
            catch (Exception ex) {
                log.severe("Erro ao cnsultar cliente: " + cliente.getCodigoCliente() + " Menssagem: " + ex.getMessage());
            }
        }

    }
}
